# Cell Model Template (CMT)
[<- back to Holarchy](../README.md)

<!-- reference -->
<!-- external references -->
[arccore filter]: https://encapsule.io/docs/ARCcore/filter
[arccore identifier]: https://encapsule.io/docs/ARCcore/identifier
<!-- core references -->
[ocd]: ./observable-controller-data.md
[opc]: ./observable-process-controller.md
[apm]: ./abstract-process-model.md
[top]: ./transition-operator.md
[act]: ./controller-action.md
[cp]: ./cell-procssor.md
[cm]: ./cell-model.md
[cmas]: ./cell-model-artifact-space.md
[cmt]: ./cell-model-template.md
<!-- root reference -->
[top list]: ../transition-operator-apis.md
[act list]: ../controller-action-apis.md



**Unoffcial Notes**
Cell Model Template (CMT) is an ES6 class instantiated with operator new that can generated [Cell Model][cm] based on ... with trackable irut id generated by inheriting method from [Cell Model Artifact Space][cmas].

**End of Unofficial Notes**

* [Construction](#Construction)
* [CMT ES6 Class APIs](#CMT-ES6-Class-APIs)
* [Example](#emxaple)
    * [Define Common Artifact](#Define-Common-Artifact)
    * [Specialize Synthesized Cell Model](#Specialize-Synthesized-Cell-Model)
        * [Direct Embedded Specialization](#Direct-Embedded-Specialization)
        * [Indirect Specialization](#Indirect-Specialization)

# Construction
To create CMT instance
```javascript
const holarchy = require("@encapsule/holarchy");

const cmtInstance = new holarchy.CellModelTemplate({
    cmasScope, // a CellModelArtifactSpace instance
    templateLabel: "your_CMT_instance_label",
    cellModelGenerator: {
        synthesizeMethodRequestSpec: {
            // a developer-defined format for sythesizeRequest namespace in .synthesizeCellModel method
        },
        generatorFilterBodyFunction: function() {
            // a developer-defined function that specialized Cell Model instance
        }
    }
});

if (!cmtInstance.isValid()) throw new Error(cmtInstance.toJSON());
module.exports = cmtInstance;
```

## cmasScope
It is the [CMAS][cmas] of this Cell Model Template which it will be used to generate conflict-free and trackable iruts for artifacts (APMs, ACTs, TOPs, CMs...) under this space.

## templateLabel
A unique and stable label (no spaces, legal JavaScript variable name token) that refers to the family of CellModel that may be synthesized by calling the constructed CellModelTemplate instance's synthesizeCellModel method.

## cellModelGenerator
It contains developer-defined information to synthesize a nique specialization of Cell Model. These values specialize the behavior of the Cell Model generator filter for the specific family of Cell Model identified by templateLabel value.

**generatorFilterBodyFunction**
This function will be invoke inside the [synthesizeCellModel(request_)](#synthesizeCellModelrequest_). It returns a object (response.result) matches [Cell Model][cm] declaration spec. 
```javascript
const generatorFilterBodyFunctionExample = function({cmtInstance, cellModelLabel, synthesizeRequest}) {
    // cmtInstance: reference to this CMT instance
    // cellModelLabel: pass through .synthesizeCellModel request_
    // synthesizeRequest: matches synthesizeMethodRequestSpec in construction, pass through .synthesizeCellModel request_

    /* 
        code to create synthesize_cm_declaration
        ....
    */
    return {result: synthesize_cm_declaration}
}
```


* It defined the **common actifacts** (ocd, Cell Model steps, ACT, TOP, sub) used across all synthesized [Cell Models][cm]:
    * check [Define Common Artifact](#Define-Common-Artifact)

* It also specialized the sythesized [Cell Model][cm] by using the information in *sythesizeRequest* namespace of [synthesizeCellModel(request_)](#synthesizeCellModelrequest_) *request_*. *sythesizeRequest* spec is defined by [synthesizeMethodRequestSpec](#synthesizeMethodRequestSpec) below. It allows CMT to specialize artifacts in the synthesize [Cell Model][cm]
    * check [Specialize Synthesized Cell Model](#Specialize-Synthesized-Cell-Model)

**synthesizeMethodRequestSpec**
It is a [arccore filter][arccore filter] spec that defined the *sythesizeRequest* namespace of [synthesizeCellModel(request_)](#synthesizeCellModelrequest_) *request_*. It contains the developer-defined information that can specialize synthesized [Cell Model][cm].
    * check [#Example](#example) for more details

# CMT ES6 Class APIs
 Method | Description |
|-|-|
| .isValid() | check whether the current CMT instance is valid or not. Return true or false |
| .toJSON() | Convert the CMT isntance into an JSON object |
| .synthesizeCellModel(request_) | synthesized a specialized cell model from request_ information |
| .mapLabels, .makeSubspaceInstance, .getArtifactSpaceLabel | inherited from [CMAS][cmas] |

## synthesizeCellModel(request_)
Once a CMT instance is constructed and valid, it can be used to create a synthesized [Cell Model][cm] with the .synthesizeCellModel(request_);
```javascript
cmtInstance.synthesizeCellModel({
    cellModelLabel: "unique_stable_label",
    sythesizeRequest: {
        // match the synthesizeMethodRequestSpec in contruction
    }
})
```

# Example
Below are examples on how CMT uses *generatorFilterBodyFunction* and *synthesizeMethodRequestSpec* to sythesized a special [Cell Model][cm].
* [Define Common Artifact](#Define-Common-Artifact)
* [Specialize Synthesized Cell Model](#Specialize-Synthesized-Cell-Model)
    * [Direct Embedded Specialization](#Direct-Embedded-Specialization)
    * [Indirect Specialization](#Indirect-Specialization)

## Define Common Artifact
Consider a simple CMT: one 
* only [OCD][ocd] namespaces (recommended): `inputs`, `_private` and `outputs`.
    * `inputs` holds a namespace *data* which is a string or undefined.
    * `_prviate` and `outputs` are empty object
* two steps - `uninitialized` and `ready`
    * `uninitialized` => `ready` if *#.inputs.data* is loaded.
* one ACT (ACT-Load) that loads a string into *#.inputs.data*
* Allow **NO** specialization on [Cell Model][cm] synthesis ( which means *synthesizeMethodRequestSpec* is empty object).

Because the CMT is for this CMT document, let's label its spacelabel `cmtDoc`.
```javascript
const holarchy = require("@encapsule/holarchy");

const templateLabel = "define_common_artifact";

const cmtInstance = new holarchy.CellModelTemplate({
    cmasScope: { spaceLabel: "cmtDoc" },
    templateLabel: templateLabel,
    cellModelGenerator: {
        synthesizeMethodRequestSpec: {
            // no specialzation => just empty synthesizeMethodRequestSpec
            ____types: "jsObject"
        },
        generatorFilterBodyFunction: function({cmtInstance, cellModelLabel, synthesizeRequest}) {
            // NOTICE: There are at least 2 spaces - cmtInstance (this CMT space) and sythesized CM space.
            // apm and cm returned are sub space of cmtInstance, we can directly use cmtInstance to make labels.
            // However, if we need to make artifacts (ACTs, TOPs, sub CMs ...) for the sythesized CM. We need to its own CMAS to make labels.
            const sythesizedCellModelCMAS = cmtInstance.makeSubspaceInstance({spaceLabel: cellModelLabel});
            
            // 1. add/create ACTs.
            // create ACT - load for sythesized Cell Model (use sythesizedCellModelCMAS)
            const actLoadID = sythesizedCellModelCMAS.mapLabels({
                ACT: "Load"
            }).result.ACTID;
            const actLoadRequestSpec = {
                ____types: "jsObejct",
                cmtDoc: {}};
            actLoadRequestSpec.cmtDoc[cellModelLabel] = {
                ____types: "jsObejct",
                load: {
                    ____types: "jsObject",
                    data: {
                        ____accept: "jsString"
                    }
                }
            }
            // ACT declaration, please refer to ACT readme for more details
            const actLoad = {
                id: actLoadID,
                name: `${cellModelLabel} - Load`,
                description: "Load data in the action request into #.inputs.data",
                // the spec can be anything as long as it is unique.
                // to avoid duplication, it is recommended to split the current space label by depth
                actionRequestSpec: actLoadRequestSpec,
                actionResultSpec: {
                    // result spec can be customized.
                    ____accept: "jsString",
                    ____inValueSet: ["success"]
                },
                bodyFunction: function({context, actionRequest}) {
                    // code to get act request data and write into #.inputs.data
                    // please check ACT readme for more details

                    return {result: "success"}
                }
            }

            // 2. add/create TOPs (skip for this example).

            // 3. add/create sub, proxy or helper CMs (skip for this example).
            // you can use CMs from other spaces or create a CMs as a sub space of the sythesized cell model

            // 4. create apm declaration with trackable irut (check APM readme for more details). 
            // .mapLabels inherit from CMAS please check (CMAS readme for more details)
            const { APMID } = cmtInstance.mapLabels({
                APM: cellModelLabel
            }).result;
            const apm = {
                id: APMID,
                name: `${templateLabel}<${cellModelLabel}>`,
                description: `CellModelTemplate<${templateLabel}> specializaiton (no specialzation for this one) for CellModel label "${cellModelLabel}"`,
                ocdDataSpec: {
                    // there will be more namespace in the following example
                    ____types: "jsObject",
                    ____defaultValue: {},
                    inputs: {
                        ____types: "jsObject",
                        ____defaultValue: {},
                    },
                    _private: {
                        ____types: "jsObject",
                        ____defaultValue: {},
                    },
                    outputs: {
                        ____types: "jsObject",
                        ____defaultValue: {},
                    }
                },
                steps: {
                    // there will be more steps
                    "uninitialized": {
                        description: "default starting process step",
                        transitions: [
                            {
                                transitionIf: {holarchy: {cm: {operators: {ocd: {isNamespaceTruthy: {path: "#.inputs.data"}}}}}},
                                nextStep: "ready"
                            }
                        ]
                    },
                    ready: {
                        description: "data received"
                    }
                }
            }

            // 5. create sythesized cm declaration (check CM readme for more details)
            const { CMID } = cmtInstance.mapLabels({
                CM: cellModelLabel
            }).result;
            const cm = {
                id: CMID,
                name: `${templateLabel}<${cellModelLabel}>`,
                description: `CellModelTemplate<${templateLabel}> specializaiton (no specialzation for this one) for CellModel label "${cellModelLabel}"`,
                apm: apm,
                actions: [], //ACTs add/created above
                operators: [], //TOPs add/created above
                subcells: [] //CMs add/created above
            }

            return {result: cm}
        }
    }
});

if (!cmtInstance.isValid()) throw new Error(cmtInstance.toJSON());

module.exports = cmtInstance;
```

To make a [Cell Model][cm] with label `cm1` and `cm2`, just simply:
```javascript
console.log(cmtInstance.synthesizeCellModel({
    cellModelLabel: "cm1",
    synthesizeRequest: {}
}));

console.log(cmtInstance.synthesizeCellModel({
    cellModelLabel: "cm2",
    synthesizeRequest: {}
}));
```

It can be seen that although *id* (CM), *apm.id* and ACT-load requet spec of `cm1` and `cm2` are different, mechanism and functionality vice (steps, ocdDataSpec and act function) are the same. They can be consider as 'same' model.

This this because no specialization allowed in this exmaple, everything defined here is common features that shared across all sythesized [Cell Models][cm]. In the follow exmaples - 



## Specialize Synthesized Cell Model

### Direct Embedded Specialization

### Indirect Specialization