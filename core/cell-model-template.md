# Cell Model Template (CMT)
[<- back to Holarchy](../README.md)

<!-- reference -->
<!-- external references -->
[arccore filter]: https://encapsule.io/docs/ARCcore/filter
[arccore identifier]: https://encapsule.io/docs/ARCcore/identifier
<!-- core references -->
[ocd]: ./observable-controller-data.md
[opc]: ./observable-process-controller.md
[apm]: ./abstract-process-model.md
[top]: ./transition-operator.md
[act]: ./controller-action.md
[cp]: ./cell-procssor.md
[cm]: ./cell-model.md
[cmas]: ./cell-model-artifact-space.md
[cmt]: ./cell-model-template.md
<!-- root reference -->
[top list]: ../transition-operator-apis.md
[act list]: ../controller-action-apis.md



**Unoffcial Notes**
Cell Model Template (CMT) is an ES6 class instantiated with operator new that can generated [Cell Model][cm] based on ... with trackable irut id generated by inheriting method from [Cell Model Artifact Space][cmas].

**End of Unofficial Notes**

* [Construction](#Construction)
* [CMT ES6 Class APIs](#CMT-ES6-Class-APIs)
* [Example](#emxaple)

# Construction
To create CMT instance
```javascript
const holarchy = require("@encapsule/holarchy");

const cmtInstance = new holarchy.CellModelTemplate({
    cmasScope, // a CellModelArtifactSpace instance
    templateLabel: "your_CMT_instance_label",
    cellModelGenerator: {
        synthesizeMethodRequestSpec: {
            // a developer-defined format for sythesizeRequest namespace in .synthesizeCellModel method
        },
        generatorFilterBodyFunction: function() {
            // a developer-defined function that specialized Cell Model instance
        }
    }
});

if (!cmtInstance.isValid()) throw new Error(cmtInstance.toJSON());
module.exports = cmtInstance;
```

## cmasScope
It is the [CMAS][cmas] of this Cell Model Template which it will be used to generate conflict-free and trackable iruts for artifacts (APMs, ACTs, TOPs, CMs...) under this space.

## templateLabel
A unique and stable label (no spaces, legal JavaScript variable name token) that refers to the family of CellModel that may be synthesized by calling the constructed CellModelTemplate instance's synthesizeCellModel method.

## cellModelGenerator
It contains developer-defined information to synthesize a nique specialization of Cell Model. These values specialize the behavior of the Cell Model generator filter for the specific family of Cell Model identified by templateLabel value.

**generatorFilterBodyFunction**
This function will be invoke inside the [synthesizeCellModel(request_)](#synthesizeCellModelrequest_). It returns a object (response.result) matches [Cell Model][cm] declaration spec. 
```javascript
const generatorFilterBodyFunctionExample = function({cmtInstance, cellModelLabel, synthesizeRequest}) {
    // cmtInstance: reference to this CMT instance
    // cellModelLabel: pass through .synthesizeCellModel request_
    // synthesizeRequest: matches synthesizeMethodRequestSpec in construction, pass through .synthesizeCellModel request_

    /* 
        code to create synthesize_cm_declaration
        ....
    */
    return {result: synthesize_cm_declaration}
}
```


* It defined the **common actifacts** (ocd, Cell Model steps, ACT, TOP, sub) used across all synthesized [Cell Models][cm]:
    * check [Define Common Artifact](#Define-Common-Artifact)

* It also specialized the sythesized [Cell Model][cm] by using the information in *sythesizeRequest* namespace of [synthesizeCellModel(request_)](#synthesizeCellModelrequest_) *request_*. *sythesizeRequest* spec is defined by [synthesizeMethodRequestSpec](#synthesizeMethodRequestSpec) below. It allows CMT to specialize artifacts in the synthesize [Cell Model][cm]
    * check [Specialize Synthesized Cell Model](#Specialize-Synthesized-Cell-Model)

**synthesizeMethodRequestSpec**
It is a [arccore filter][arccore filter] spec that defined the *sythesizeRequest* namespace of [synthesizeCellModel(request_)](#synthesizeCellModelrequest_) *request_*. It contains the developer-defined information that can specialize synthesized [Cell Model][cm].
    * check [#Example](#example) for more details

# CMT ES6 Class APIs
 Method | Description |
|-|-|
| .isValid() | check whether the current CMT instance is valid or not. Return true or false |
| .toJSON() | Convert the CMT isntance into an JSON object |
| .synthesizeCellModel(request_) | synthesized a specialized cell model from request_ information |
| .mapLabels, .makeSubspaceInstance, .getArtifactSpaceLabel | inherited from [CMAS][cmas] |

## synthesizeCellModel(request_)
Once a CMT instance is constructed and valid, it can be used to create a synthesized [Cell Model][cm] with the .synthesizeCellModel(request_);
```javascript
cmtInstance.synthesizeCellModel({
    cellModelLabel: "unique_stable_label",
    sythesizeRequest: {
        // match the synthesizeMethodRequestSpec in contruction
    }
})
```

# Example
Below are examples on how CMT uses *generatorFilterBodyFunction* and *synthesizeMethodRequestSpec* to sythesized a special [Cell Model][cm].

## Define Common Artifact
Consider a simple CMT: one 
* with only default "uninitialized" step
* only [OCD][ocd] namespaces (recommended): `inputs`, `_private` and `outputs` that hold an empty object (They can hold future specialize namespaces)
* NO other artifacts (ACTs, TOPs, sub CMs...);
* Allow **NO** specialization on [Cell Model][cm] synthesis (*synthesizeMethodRequestSpec* is empty object).

Because the CMT is for this CMT document, let's label its spacelabel `cmtDoc`.
```javascript
const holarchy = require("@encapsule/holarchy");

const templateLabel = "define_common_artifact";

const cmtInstance = new holarchy.CellModelTemplate({
    cmasScope: { spaceLabel: "cmtDoc" },
    templateLabel: templateLabel,
    cellModelGenerator: {
        synthesizeMethodRequestSpec: {
            // no specialzation => just empty synthesizeMethodRequestSpec
            ____types: "jsObject"
        },
        generatorFilterBodyFunction: function({cmtInstance, cellModelLabel, synthesizeRequest}) {
            // 1. add/create ACTs (skip for this example).

            // 2. add/create TOPs (skip for this example).

            // 3. add/create sub, proxy or helper CMs (skip for this example).

            // 4. create apm declaration with trackable irut (check APM readme for more details). 
            // .mapLabels inherit from CMAS please check (CMAS readme for more details)
            const { APMID } = cmtInstance.mapLabels({
                APM: cellModelLabel
            }).result;
            const apm = {
                id: APMID,
                name: `${templateLabel}<${cellModelLabel}>`,
                description: `CellModelTemplate<${templateLabel}> specializaiton (no specialzation for this one) for CellModel label "${cellModelLabel}"`,
                ocdDataSpec: {
                    // there will be more namespace in the following example
                    ____types: "jsObject",
                    ____defaultValue: {},
                    inputs: {
                        ____types: "jsObject",
                        ____defaultValue: {},
                    },
                    _private: {
                        ____types: "jsObject",
                        ____defaultValue: {},
                    },
                    outputs: {
                        ____types: "jsObject",
                        ____defaultValue: {},
                    }
                },
                steps: {
                    // there will be more steps
                    "uninitialized": {
                        description: "default starting process step"
                    }
                }
            }

            // 5. create sythesized cm declaration (check CM readme for more details)
            const { CMID } = cmtInstance.mapLabels({
                CM: cellModelLabel
            }).result;
            const cm = {
                id: CMID,
                name: `${templateLabel}<${cellModelLabel}>`,
                description: `CellModelTemplate<${templateLabel}> specializaiton (no specialzation for this one) for CellModel label "${cellModelLabel}"`,
                apm: apm,
                actions: [], //ACTs add/created above
                operators: [], //TOPs add/created above
                subcells: [] //CMs add/created above
            }

            return {result: cm}
        }
    }
});

if (!cmtInstance.isValid()) throw new Error(cmtInstance.toJSON());

module.exports = cmtInstance;
```

To make a [Cell Model][cm] with label `cm1`, just simply:
```javascript
console.log(cmtInstance.synthesizeCellModel({
    cellModelLabel: "cm1",
    synthesizeRequest: {}
}));
```



## Specialize Synthesized Cell Model
* [Specialize OCD Spec](#Specialize-OCD-Spec)
* [Specialize APM Step](#Specialize-APM-Step)
* [Specialize ACTs, TOPs and sub CMs](#Specialize-ACTs,-TOPs-and-sub-CMs)
* [Specialize Proxy or Helper](#Specialize-Proxy-or-Helper)

### Specialize OCD Spec

### Specialize APM Step

### Specialize ACTs, TOPs and sub CMs

### Specialize Proxy or Helper