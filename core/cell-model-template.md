# Cell Model Template (CMT)
[<- back to Holarchy](../README.md)

<!-- reference -->
<!-- external references -->
[arccore filter]: https://encapsule.io/docs/ARCcore/filter
[arccore identifier]: https://encapsule.io/docs/ARCcore/identifier
<!-- core references -->
[ocd]: ./observable-controller-data.md
[opc]: ./observable-process-controller.md
[apm]: ./abstract-process-model.md
[top]: ./transition-operator.md
[act]: ./controller-action.md
[cp]: ./cell-procssor.md
[cm]: ./cell-model.md
[cmas]: ./cell-model-artifact-space.md
[cmt]: ./cell-model-template.md
<!-- root reference -->
[top list]: ../transition-operator-apis.md
[act list]: ../controller-action-apis.md



**Unoffcial Notes**

Cell Model Template (CMT) is an ES6 class instantiated with operator new that can generated [Cell Models][cm] with developer-defined common patterns (artifacts) and specilization based on inputs with trackable irut id generated by inheriting method from [Cell Model Artifact Space][cmas].

CMT might seem to be redundant at a glance for creating simple [Cell Model][cm]. But it is extremely useful to develop [Cell Models][cm] with complex shared patterns ([OCD][ocd] spec, [ACT][act], [TOP][top]...).

**End of Unofficial Notes**

* [Construction](#Construction)
* [CMT ES6 Class APIs](#CMT-ES6-Class-APIs)
* [Example](#emxaple)
    * [Define Common Artifact](#Define-Common-Artifact)
    * [Specialize Synthesized Cell Model](#Specialize-Synthesized-Cell-Model)
        * [Direct Embedded Specialization](#Direct-Embedded-Specialization)
        * [Indirect Specialization](#Indirect-Specialization)

# Construction
To create CMT instance
```javascript
const holarchy = require("@encapsule/holarchy");

const cmtInstance = new holarchy.CellModelTemplate({
    cmasScope, // a CellModelArtifactSpace instance
    templateLabel: "your_CMT_instance_label",
    cellModelGenerator: {
        specializationDataSpec: {
            // a developer-defined format for sythesizeRequest namespace in .synthesizeCellModel method
        },
        generatorFilterBodyFunction: function() {
            // a developer-defined function that specialized Cell Model instance
        }
    }
});

if (!cmtInstance.isValid()) throw new Error(cmtInstance.toJSON());
module.exports = cmtInstance;
```

## cmasScope
It is the [CMAS][cmas] of this Cell Model Template which it will be used to generate conflict-free and trackable iruts for artifacts (APMs, ACTs, TOPs, CMs...) under this space.

## templateLabel
A unique and stable label (no spaces, legal JavaScript variable name token) that refers to the family of CellModel that may be synthesized by calling the constructed CellModelTemplate instance's synthesizeCellModel method.

## cellModelGenerator
It contains developer-defined information to synthesize a nique specialization of Cell Model. These values specialize the behavior of the Cell Model generator filter for the specific family of Cell Model identified by templateLabel value.

**generatorFilterBodyFunction**
This function will be invoke inside the [synthesizeCellModel(request_)](#synthesizeCellModelrequest_). It returns a object (response.result) matches [Cell Model][cm] declaration spec. 
```javascript
const generatorFilterBodyFunctionExample = function({cmtInstance, cellModelLabel, specializationData}) {
    // cmtInstance: reference to this CMT instance
    // cellModelLabel: pass through .synthesizeCellModel request_
    // specializationData: matches synthesizeMethodRequestSpec in construction, pass through .synthesizeCellModel request_

    /* 
        code to create synthesize_cm_declaration
        ....
    */
    return {result: synthesize_cm_declaration}
}
```


* It defined the **common actifacts** (ocd, Cell Model steps, ACT, TOP, sub) used across all synthesized [Cell Models][cm]:
    * check [Define Common Artifact](#Define-Common-Artifact)

* It also specialized the sythesized [Cell Model][cm] by using the information in *sythesizeRequest* namespace of [synthesizeCellModel(request_)](#synthesizeCellModelrequest_) *request_*. *sythesizeRequest* spec is defined by [synthesizeMethodRequestSpec](#synthesizeMethodRequestSpec) below. It allows CMT to specialize artifacts in the synthesize [Cell Model][cm]
    * check [Specialize Synthesized Cell Model](#Specialize-Synthesized-Cell-Model)

**specializationDataSpec**
It is a [arccore filter][arccore filter] spec that defined the *sythesizeRequest* namespace of [synthesizeCellModel(request_)](#synthesizeCellModelrequest_) *request_*. It contains the developer-defined information that can specialize synthesized [Cell Model][cm].
    * check [#Example](#example) for more details

# CMT ES6 Class APIs
 Method | Description |
|-|-|
| .isValid() | check whether the current CMT instance is valid or not. Return true or false |
| .toJSON() | Convert the CMT isntance into an JSON object |
| .synthesizeCellModel(request_) | synthesized a specialized cell model from request_ information |
| .mapLabels, .makeSubspaceInstance, .getArtifactSpaceLabel | inherited from [CMAS][cmas] |

## synthesizeCellModel(request_)
Once a CMT instance is constructed and valid, it can be used to create a synthesized [Cell Model][cm] with the .synthesizeCellModel(request_);
```javascript
cmtInstance.synthesizeCellModel({
    cellModelLabel: "unique_stable_label",
    sythesizeRequest: {
        // match the synthesizeMethodRequestSpec in contruction
    }
})
```

# Example
Below are examples on how CMT uses *generatorFilterBodyFunction* and *synthesizeMethodRequestSpec* to sythesized a special [Cell Model][cm].
* [Define Common Artifact](#Define-Common-Artifact)
* [Specialize Synthesized Cell Model](#Specialize-Synthesized-Cell-Model)
    * [Direct Embedded Specialization](#Direct-Embedded-Specialization)
    * [Indirect Specialization](#Indirect-Specialization)

## Define Common Artifact
Consider a simple CMT: one 
* only [OCD][ocd] namespaces (recommended): `inputs`, `_private` and `outputs`.
    * `inputs` holds a namespace *data* which is a string or undefined.
    * `_prviate` and `outputs` are empty object
* two steps - `uninitialized` and `ready`
    * `uninitialized` => `ready` if *#.inputs.data* is loaded.
* one ACT (ACT-Load) that loads a string into *#.inputs.data*
* Allow **NO** specialization on [Cell Model][cm] synthesis ( which means *specializationDataSpec* is empty object).

Because the CMT is for this CMT document, let's label its spacelabel `cmtDoc`.
```javascript
const holarchy = require("@encapsule/holarchy");

const templateLabel = "define_common_artifact";

const cmtInstance = new holarchy.CellModelTemplate({
    cmasScope: { spaceLabel: "cmtDoc" },
    templateLabel: templateLabel,
    cellModelGenerator: {
        specializationDataSpec: {
            // no specialzation => just empty specializationDataSpec
            ____types: "jsObject"
        },
        generatorFilterBodyFunction: function({cmtInstance, cellModelLabel, specializationData}) {
            // NOTICE: There are at least 2 spaces - cmtInstance (this CMT space) and sythesized CM space.
            // apm and cm returned are sub space of cmtInstance, we can directly use cmtInstance to make labels.
            // However, if we need to make artifacts (ACTs, TOPs, sub CMs ...) for the sythesized CM. We need to its own CMAS to make labels.
            const sythesizedCellModelCMAS = cmtInstance.makeSubspaceInstance({spaceLabel: cellModelLabel});
            
            // 1. add/create ACTs.
            // create ACT - load for sythesized Cell Model (use sythesizedCellModelCMAS)
            const actLoadID = sythesizedCellModelCMAS.mapLabels({
                ACT: "Load"
            }).result.ACTID;
            const actLoadRequestSpec = {
                ____types: "jsObejct",
                cmtDoc: {}};
            actLoadRequestSpec.cmtDoc[cellModelLabel] = {
                ____types: "jsObejct",
                load: {
                    ____types: "jsObject",
                    data: {
                        ____accept: "jsString"
                    }
                }
            }
            // ACT declaration, please refer to ACT readme for more details
            const actLoad = {
                id: actLoadID,
                name: `${cellModelLabel} - Load`,
                description: "Load data in the action request into #.inputs.data",
                // the spec can be anything as long as it is unique.
                // to avoid duplication, it is recommended to split the current space label by depth
                actionRequestSpec: actLoadRequestSpec,
                actionResultSpec: {
                    // result spec can be customized.
                    ____accept: "jsString",
                    ____inValueSet: ["success"]
                },
                bodyFunction: function({context, actionRequest}) {
                    // code to get act request data and write into #.inputs.data
                    // please check ACT readme for more details

                    return {result: "success"}
                }
            }

            // 2. add/create TOPs (skip for this example).

            // 3. add/create sub, proxy or helper CMs (skip for this example).
            // you can use CMs from other spaces or create a CMs as a sub space of the sythesized cell model

            // 4. create apm declaration with trackable irut (check APM readme for more details). 
            // .mapLabels inherit from CMAS please check (CMAS readme for more details)
            const { APMID } = cmtInstance.mapLabels({
                APM: cellModelLabel
            }).result;
            const apm = {
                id: APMID,
                name: `${templateLabel}<${cellModelLabel}>`,
                description: `CellModelTemplate<${templateLabel}> specializaiton (no specialzation for this one) for CellModel label "${cellModelLabel}"`,
                ocdDataSpec: {
                    // there will be more namespace in the following example
                    ____types: "jsObject",
                    ____defaultValue: {},
                    inputs: {
                        ____types: "jsObject",
                        ____defaultValue: {},
                        data: { ____accept: ["jsString", "jsUndefined] }
                    },
                    _private: {
                        ____types: "jsObject",
                        ____defaultValue: {},
                    },
                    outputs: {
                        ____types: "jsObject",
                        ____defaultValue: {},
                    }
                },
                steps: {
                    // there will be more steps
                    "uninitialized": {
                        description: "default starting process step",
                        transitions: [
                            {
                                transitionIf: {holarchy: {cm: {operators: {ocd: {isNamespaceTruthy: {path: "#.inputs.data"}}}}}},
                                nextStep: "ready"
                            }
                        ]
                    },
                    ready: {
                        description: "data received"
                    }
                }
            }

            // 5. create sythesized cm declaration (check CM readme for more details)
            const { CMID } = cmtInstance.mapLabels({
                CM: cellModelLabel
            }).result;
            const cm = {
                id: CMID,
                name: `${templateLabel}<${cellModelLabel}>`,
                description: `CellModelTemplate<${templateLabel}> specializaiton (no specialzation for this one) for CellModel label "${cellModelLabel}"`,
                apm: apm,
                actions: [], //ACTs add/created above
                operators: [], //TOPs add/created above
                subcells: [] //CMs add/created above
            }

            return {result: cm}
        }
    }
});

if (!cmtInstance.isValid()) throw new Error(cmtInstance.toJSON());

module.exports = cmtInstance;
```

To make a [Cell Model][cm] with label `cm1` and `cm2`, just simply:
```javascript
let synthesizeResponse = cmtInstance.synthesizeCellModel({
    cellModelLabel: "cm1",
    specializationData: {}
});
if (synthesizeResponse.error) throw new Error(synthesizeResponse.error);
const cm1Declaration = synthesizeResponse.result;
console.log(cm1Declaration)

synthesizeResponse = cmtInstance.synthesizeCellModel({
    cellModelLabel: "cm2",
    specializationData: {}
});
if (synthesizeResponse.error) throw new Error(synthesizeResponse.error);
const cm2Declaration = synthesizeResponse.result;
console.log(cm2Declaration)
```

It can be seen that although *id* (CM), *.apm.id* and ACT-load requet spec of `cm1` and `cm2` are different, mechanism and functionality vice (steps, ocdDataSpec and act function) are the same. They can be consider as 'same' model.

This this because no specialization allowed in this exmaple, everything defined here is common features that shared across all sythesized [Cell Models][cm]. In the follow exmaples, it will show how CMT uses *specializationData* to conveniently create CMs with different mechanisms.

## Specialize Synthesized Cell Model
There are two ways to specialize the sythesized CM, both through the information from *specializationData*:
* Direct Embedded Specialization: directly include artifacts declarations in *specializationData* and add them without any changes into corresponding namesapces in the return CM declaration of *.synthesizeCellModel* method.

* Indirect Specialization: artifacts inside the CM based on the *specializationData*.

### Direct Embedded Specialization
It is a straightforward way to specialize a sythesized Cell Model:
1. declare spec for necessary artifacts
2. add them into CM declaration in the *generatorFilterBodyFunction*

Let's us the example in the [Define Common Artifact](#Define-Common-Artifact) again. But this time, we want the CMT to add any developer-defined ACT, OCD, and steps. So at CMT instantiation, namespace *additional* and its sub namespace (*outputsSpec*, *steps* and *ACT*) are added in the  *specializationDataSpec* as container for these information. And in *generatorFilterBodyFunction*, they are directly embeded into return CM declaration.

*NOTICE*, as information in *addtional* are directly unpacked into return CM declaration, it also give the developer access to overwrite the current artifacts

```javascript
const cmtInstance = new holarchy.CellModelTemplate({
    cmasScope: { spaceLabel: "cmtDoc" },
    templateLabel: templateLabel,
    cellModelGenerator: {
        specializationDataSpec: {
            // no specialzation => just empty synthesizeMethodRequestSpec
            ____types: "jsObject",

            // 1. declare the namespace container 
            // namespace of your choice. You can use whatever feels convenient to you.
            additional: {
                ____types: "jsObject",
                outputsSpec: { ____accept: "jsObject" },
                steps: { 
                    ____types: "jsObject",
                    ____asMap: true,
                    ____defaultValue: {},
                    stepName: { ____accept: "jsObject" } // recommend to use step spec from APM
                }, 
                actions: { 
                    ____types: "jsArray",
                    ____defaultValue: [],
                    action: { 
                        ____types: "jsObject",
                        label: { ____accept: "jsString" }, // recommend to use label to let CMT itself to figure out a irut for you,
                        description: { ____accept: "jsString" },
                        actionRequestSpec: { ____accept: "jsObject" },
                        actionResultSpec: { ____accept: "jsObject" },
                        bodyFunction: { ____accept: "jsFunction" }
                    }
                }, 
            }
        },
        generatorFilterBodyFunction: function({cmtInstance, cellModelLabel, specializationData}) {
            const sythesizedCellModelCMAS = cmtInstance.makeSubspaceInstance({spaceLabel: cellModelLabel});
            const {outputsSpec, steps, actions } = specializationData.additional;

            // 1. add/create ACTs.
            const actionMap = {}; // use map to overwrite ACT with same label
            // get default ACTs
            const actLoadDescriptor = {...}; // same as in Define Common Artifact but use label instead of name and id. 

            [actLoadDescriptor, ...actions].forEach(actionDescriptor => {
                const { ACTID } = sythesizedCellModelCMAS.mapLabels({
                    ACT: actionDescriptor.label
                }).result;

                actionMap[actionDescriptor.label] = {
                    id: ACTID,
                    name: `${cellModelLabel} - ${actionDescriptor.label}`,
                    description: actionDescriptor.description,
                    actionRequestSpec: actionDescriptor.actionRequestSpec,
                    actionResultSpec: actionDescriptor.actionResultSpec,
                    bodyFunction: function({context, actionRequest}) {
                        // code to get act request data and write into #.inputs.data
                        // please check ACT readme for more details
    
                        return {result: "success"}
                    }
                }
            })

            // 4. create apm declaration with trackable irut (check APM readme for more details). 
            const { APMID } = cmtInstance.mapLabels({
                APM: cellModelLabel
            }).result;
            const apm = {
                id: APMID,
                name: `${templateLabel}<${cellModelLabel}>`,
                description: `CellModelTemplate<${templateLabel}> specializaiton for CellModel label "${cellModelLabel}"`,
                ocdDataSpec: {
                    ____types: "jsObject",
                    ____defaultValue: {},
                    inputs: {
                        ____types: "jsObject",
                        ____defaultValue: {},
                        data: { ____accept: ["jsString", "jsUndefined"] }
                    },
                    _private: {
                        ____types: "jsObject",
                        ____defaultValue: {},
                    },
                    outputs: {
                        ____types: "jsObject",
                        ____defaultValue: {},

                        // unpack outputs spec
                        ...outputsSpec
                    }
                },
                steps: {
                    // there will be more steps
                    "uninitialized": {
                        description: "default starting process step",
                        transitions: [
                            {
                                transitionIf: {holarchy: {cm: {operators: {ocd: {isNamespaceTruthy: {path: "#.inputs.data"}}}}}},
                                nextStep: "ready"
                            }
                        ]
                    },
                    ready: {
                        description: "data received"
                    },
                    // unpack steps
                    ...steps
                }
            }

            // 5. create sythesized cm declaration (check CM readme for more details)
            const { CMID } = cmtInstance.mapLabels({
                CM: cellModelLabel
            }).result;
            const cm = {
                id: CMID,
                name: `${templateLabel}<${cellModelLabel}>`,
                description: `CellModelTemplate<${templateLabel}> specializaiton for CellModel label "${cellModelLabel}"`,
                apm: apm,
                actions: Object.keys(actionMap).map(key => actionMap[key]), //ACTs add/created above
                operators: [], //TOPs add/created above
                subcells: [] //CMs add/created above
            }

            return {result: cm}
        }
    }
});

if (!cmtInstance.isValid()) throw new Error(cmtInstance.toJSON());
```

Now a CMT that can specialize outputs OCD spec, APM steps and ACTs are created.

Let's use it to create an sythesized Cell Model that:
1. has an *error* namespace in *#.outputs*
2. has an error step that if there is error, APM will transit to this step.

```javascript
const cm1 = cmtInstance.synthesizeCellModel({
    cellModelLabel: "cm1",
    specializationData: {
        additional: {
            outputsSpec: {
                error: { ____accept: ["jsString", "jsUndefined"] }
            },
            steps: {
                ready: {
                    description: "ready",
                    transitions: [
                        {
                            transitionIf: {holarchy: {cm: {operators: {ocd: {isNamespaceTruthy: {path: "#.outputs.error"}}}}}},
                            nextStep: "error"
                        }
                    ]
                },
                error: {
                    description: "error",
                    transitions: [
                        {
                            transitionIf: {not: {holarchy: {cm: {operators: {ocd: {isNamespaceTruthy: {path: "#.outputs.error"}}}}}}},
                            nextStep: "ready"
                        }
                    ]
                }
            },
        }
    }
}).result
console.log(cm1)
```

### Indirect Specialization
The indreict Specialzation is probably the most cases that CMT will be applied. In this situation, one or more artifacts is uncertain (type, namespace... is unknown) for the sythesized Cell Model and there are artifacts dependent on it. So CMT need to generate Cell Model based on the specialization of the uncertain artifacts.

For example, from the [Define Common Artifact](#Define-Common-Artifact) example again. But this time, we need different Cell Models based on the type of *#.inputs.data*. It might an array, a string, a number and ... So, the following has to be specialized for different situation:
* *#.inputs.data* spec
* ACT - Load actionRequestSpec
* transition condition of *uninitialized* step.

```javascript
const holarchy = require("@encapsule/holarchy");

const templateLabel = "indirect_specialization";

const cmtInstance = new holarchy.CellModelTemplate({
    cmasScope: { spaceLabel: "cmtDoc" },
    templateLabel: templateLabel,
    cellModelGenerator: {
        specializationDataSpec: {
            // no specialzation => just empty synthesizeMethodRequestSpec
            ____types: "jsObject",
            inputsDataSpec: { 
                //  the data spec descriptor is always an object,
                ____accept: "jsObject"
            }
        },
        generatorFilterBodyFunction: function({cmtInstance, cellModelLabel, specializationData}) {
            const sythesizedCellModelCMAS = cmtInstance.makeSubspaceInstance({spaceLabel: cellModelLabel});
            const { inputsDataSpec } = specializationData
            
            // 1. add/create ACTs.
            const actLoadID = sythesizedCellModelCMAS.mapLabels({
                ACT: "Load"
            }).result.ACTID;
            const actLoadRequestSpec = {
                ____types: "jsObejct",
                cmtDoc: {}};
            actLoadRequestSpec.cmtDoc[cellModelLabel] = {
                ____types: "jsObejct",
                load: {
                    ____types: "jsObject",
                    // Load ACT is based on inputsDataSpec
                    data: inputsDataSpec
                }
            };
            // same as in Define Common Artifact
            const actLoad = {...}

            // uninitialized step is based on data
            let uninitializedStep = {
                description: "default starting process step",
                transitions: [
                    {
                        transitionIf: {holarchy: {cm: {operators: {ocd: {isNamespaceTruthy: {path: "#.inputs.data"}}}}}},
                        nextStep: "ready"
                    }
                ]
            }

            if (typeof inputsDataSpec.____types === "string" ||  typeof inputsDataSpec.____accept === "string") {
                const dataType = inputsDataSpec.____types || inputsDataSpec.____accept;
                if (dataType === "jsArray") {
                    uninitializedStep = {
                        description: "default starting process step",
                        transitions: [
                            {
                                transitionIf: {holarchy: {cm: {operators: {ocd: {arrayIsEmpty: {path: "#.inputs.data"}}}}}},
                                nextStep: "ready"
                            }
                        ]
                    }
                }
            }

            const { APMID } = cmtInstance.mapLabels({
                APM: cellModelLabel
            }).result;
            const apm = {
                id: APMID,
                name: `${templateLabel}<${cellModelLabel}>`,
                description: `CellModelTemplate<${templateLabel}> specializaiton (no specialzation for this one) for CellModel label "${cellModelLabel}"`,
                ocdDataSpec: {
                    // there will be more namespace in the following example
                    ____types: "jsObject",
                    ____defaultValue: {},
                    inputs: {
                        ____types: "jsObject",
                        ____defaultValue: {},
                        data: inputsDataSpec
                    },
                    _private: {
                        ____types: "jsObject",
                        ____defaultValue: {},
                    },
                    outputs: {
                        ____types: "jsObject",
                        ____defaultValue: {},
                    }
                },
                steps: {
                    // there will be more steps
                    "uninitialized": uninitializedStep,
                    ready: {
                        description: "data received"
                    }
                }
            }

            // 5. create sythesized cm declaration (check CM readme for more details)
            // same as in Define Common Artifact.
            const cm = {}

            return {result: cm}
        }
    }
});

if (!cmtInstance.isValid()) throw new Error(cmtInstance.toJSON());
```

It can be seen that how the ACT-Load, unintialized step and of course *#.inputs.data* are specialized by the *speclizationData*.

Suppose, we want to create a Cell Model with all the common functionalities and array type *#.inputs.data*. Instead of writing the whole Cell Model. We can simply do:

```javascript
const synthesizeResponse = cmtInstance.synthesizeCellModel({
    cellModelLabel: "array_data",
    specializationData: {
        inputsDataSpec: { 
            ____accept: "jsArray",
            ____defaultValue: []
        }
    }
});
if (synthesizeResponse.error) throw new Error (synthesizeResponse.error);
const arrayCM = synthesizeResponse.result;
```
